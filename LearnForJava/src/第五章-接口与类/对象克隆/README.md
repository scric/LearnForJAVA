## 对象克隆

当拷贝一个变量时, 原始变量与拷贝变量引用同一个对象. 也就是说, 改变一个变量所引用的对象将会对另一个变量产生影响

我们可以从 testForCopy 中看到, 改变一个变量所引用的对象将也会对另一个变量产生影响.

如果我们想创建一个对象的新的 copy, 它的最初状态和 original 一样, 但以后将可以各自改变各自的状态呢? 

这时候我们就应该使用 对象克隆, 也就是 clone 方法.

对象的克隆是指创建一个新对象, 且新对象的状态与原始对象的状态相同, 当对克隆的新对象进行修改时, 不会影响原始对象的状态.

详细的, 我们可以看 testForClone

对于每一个类, 都需要作出下列判断:
7
+ 默认的 clone 方法是否满足要求?
+ 默认的 clone 方法是否能够通过调用可变子对象的 clone 得到修补.
+ 是否不应该使用 clone

实际上, 选项 3 是默认的. 如果要选择 1 或 2 ,类必须:

+ 实现 Cloneable 接口

+ 使用 public 访问修饰符重新定义 clone 方法
 
### # 注释

+ 在 Object 类中, clone 方法被声明为 protected, 因此无法直接调用 anObject.clone().

+ 子类只能调用受保护的 clone 方法克隆它自己. 因此 ,必须重新定义 clone 方法, 并将它声明为 public, 这样才能让所有的方法克隆对象.

+ 所有的数组类型均包含一个 clone 方法, 这个方法被设为 public ,而不是 protected
 
 
 
### 关于 clone 的知识点 可以看 CloneTest


